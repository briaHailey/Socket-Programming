"""
Name: Bria Weisblat
Date: 10/23/24
Assignment: Assignment #4
Due Date: 10/30/24
About this project: This project allows two people to play Tic-Tac-Toe over the internet. This
project uses socket programming to establish a server and a client that send moves back and
forth to play Tic-Tac-Toe.
Assumptions: Assume players take turns properly and in order. Assume the connection will not
be lost mid-game. Assume the client and server will not crash.
All work below was performed solely by Bria Weisblat.
I used code generated by an AI tool.
"""

import socket
import sys
import os

def display_board(board):
    print("  1 2 3")
    print("A " + ' '.join(board[0]))
    print("B " + ' '.join(board[1]))
    print("C " + ' '.join(board[2]))

def convert_move_to_index(move):
    # Dict that converts row letter into an index
    row_map = {'A': 0, 'B': 1, 'C': 2}

    # Dict that converts column number into an index
    col_map = {'1': 0, '2': 1, '3': 2}

    # If the entered move is valid
    if len(move) == 2 and move[0] in row_map and move[1] in col_map:
        # Convert the row move
        row = row_map[move[0]]
        # Convert the column move
        col = col_map[move[1]]
        # Return the row and column
        return row, col
    # For an invalid move
    return -1, -1


def check_done(board):
    # Check rows and columns
    for i in range(3):
        # Check each row for a '#' win
        if all(cell == '#' for cell in board[i]):
            return '#'
        # Check each column for a '#' win
        if all(board[j][i] == '#' for j in range(3)):
            return '#'
        # Check each row for a 'O' win
        if all(cell == 'O' for cell in board[i]):
            return 'O'
        # Check each column for a 'O' win
        if all(board[j][i] == 'O' for j in range(3)):
            return 'O'

    # Check first diagonal for '#' win
    if all(board[i][i] == '#' for i in range(3)):
        return '#'
    # Check second diagonal for '#' win
    if all(board[i][2 - i] == '#' for i in range(3)):
        return '#'
    # Check first diagonal for 'O' win
    if all(board[i][i] == 'O' for i in range(3)):
        return 'O'
    # Check second diagonal for 'O' win
    if all(board[i][2 - i] == 'O' for i in range(3)):
        return 'O'

    # Check for a tie
    if all(cell in ['#', 'O'] for row in board for cell in row):
        return 'TIE'

    # The game is not over yet
    return None


def play_game():

    # Receive the initial game board and prompt for the first move
    data = s.recv(1000).decode()

    # Create a blank starting board
    board = [['.' for _ in range(3)] for _ in range(3)]

    # Loop through each spot on the board
    for i in range(3):
        for j in range(3):
            # Populate the board with the values received from the server
            board[i][j] = data[i * 3 + j]
    # Print the board
    display_board(board)

    while True:
        # Prompt the user to enter their move
        move = input("Enter a move([ABC][123]): ").upper()

        # Convert the move to index form
        row, col = convert_move_to_index(move)

        # Validate the move
        if row == -1 or board[row][col] != '.':
            print("Invalid move. Try again.")
            continue

        # Send the move to the server
        s.send(move.encode())

        # Receive updated board after the move
        data = s.recv(1000).decode()

        # Update the board with the new move from the server
        for i in range(3):
            for j in range(3):
                board[i][j] = data[i * 3 + j]

        # Display the board after your move
        display_board(board)

        # Check if the game is over (WIN, DRAW)
        if data[9:].startswith("WIN") or data[9:].startswith("DRAW"):
            print(data[9:])  # WIN or DRAW message
            break

        print("Wait for your opponent move (don't type anything)!")

        # Receive the opponent's move and update the board
        data = s.recv(1000).decode()
        board = [['.' for _ in range(3)] for _ in range(3)]
        for i in range(3):
            for j in range(3):
                board[i][j] = data[i * 3 + j]

        # Display the updated board after the server's move
        display_board(board)

        # Check if the game is over
        result = check_done(board)

        print(f"Opponent played {data}. ")

        # If # won
        if result == '#':
            # Print the final board and declare a winner
            display_board(board)
            print("Player '#' wins!")
            sys.stdout.flush()
            break
        # If 0 won
        elif result == 'O':
            # Print the final board and declare a winner
            display_board(board)
            print("Player 'O' wins!")
            break
        # If the board is full and no one won
        elif result == 'TIE':
            # Print the final board and declare a tie
            display_board(board)
            print("It's a tie!")
            break

# Count the number of command line arguments
n = len(sys.argv)

#If there are not two command line arguments
if n != 3:
    # Print error message
    print("Usage: server_name port")
    exit()

# Create a socket
s = socket.socket()

try:
    # Connect to the server using the address and port from the command-line arguments
    s.connect((sys.argv[1], int(sys.argv[2])))

# If the client cannot connect to the server
except socket.error as errorMessage:
    # Print an error message
    print(f'failed to connect. {errorMessage}')
    exit()

# Start the game
play_game()

# Close the socket after the game ends
s.close()
